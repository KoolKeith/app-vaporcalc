#!perl

use Defaults::Modern
  -with_types => [ 'App::vaporcalc::Types' ];

use App::vaporcalc::CmdEngine;
use App::vaporcalc::Recipe;

use Term::UI;
use Term::ReadLine;
my $termpkg = 
  $ENV{PERL_RL} 
  || try { use_module('Term::ReadLine::Perl5') }
  || try { use_module('Term::ReadLine::Perl')  }
  || 'Term::ReadLine';
my $term  = $termpkg->new('vcalc'); 
my $outfh = $term->OUT || \*STDOUT;
$outfh->autoflush(1);

$outfh->say('Welcome to App::vaporcalc!');

my $cmdeng = App::vaporcalc::CmdEngine->new;

my $orig_prompt = 'vcalc> ';
my $prompt;
my $recipe; # FIXME init a baseline recipe to tweak
PROMPT: while (1) {
  $prompt //= $orig_prompt;

  my $input = $term->get_reply(
    prompt  => $prompt,
    default => 'help'
  );

  next PROMPT unless $input;

  $term->addhistory($input);

  if ($input =~ /^(?:exit|quit)/i) {
    last PROMPT
  }

  my $parsed = try {
    $cmdeng->parse_cmd($input)
  } catch {
    $outfh->say( ">> Parser err: $_" );
    next PROMPT
  };

  my $cmd_result = try {
    $cmdeng->prepare_cmd(
      subject => $parsed->subject,
      verb    => $parsed->verb,
      params  => $parsed->params,
      recipe  => $recipe,
    )->execute
  } catch {
    $outfh->say( ">> Cmd err: $_" );
    next PROMPT
  };

  # FIXME clean this up w/ CmdResult objects:
  if (is_RecipeObject $cmd_result) {
    $recipe = $cmd_result
  } elsif (is_RecipeResultSet $cmd_result) {
    $recipe = $cmd_result->recipe;
    # FIXME automagically print formatted when we get resultset?
    #  abstract out template from -simple ?
  } elsif (is_Str $cmd_result) {
    # String came back, print it:
    $outfh->say($cmd_result);
  } elsif ( is_ArrayObj($cmd_result) || is_ArrayRef($cmd_result) ) {
    # Feeding back an ARRAY controls the input loop:
    last PROMPT if $cmd_result->[0] eq 'exit' or $cmd_result->[0] eq 'quit';
    next PROMPT if $cmd_result->[0] eq 'next';
  }

  ### FIXME kill default_verb bits in ParseCmd / Cmd.pm
  ###   let subject classes handle missing verb by overriding 'has verb'
}


say "Bye!"; exit 0
