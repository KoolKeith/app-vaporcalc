#!perl

use Defaults::Modern
  -with_types => [ 'App::vaporcalc::Types' ];

use Module::Runtime 'use_module';

use App::vaporcalc::RecipeResultSet;

use Term::UI;
use Term::ReadLine;
my $termpkg = 
  $ENV{PERL_RL} 
  || try { use_module('Term::ReadLine::Perl5') }
  || try { use_module('Term::ReadLine::Perl')  }
  || 'Term::ReadLine';
my $term  = $termpkg->new('vcalc'); 
my $outfh = $term->OUT || \*STDOUT;
$outfh->autoflush(1);

$outfh->say('Welcome to App::vaporcalc!');

my $cmdeng = App::vaporcalc::Cmd->new;

my $orig_prompt = 'vcalc> ';
my ($prompt, $recipe);
PROMPT: while (1) {
  $prompt //= $orig_prompt;

  my $input = $term->get_reply(
    prompt  => $prompt,
    default => 'help'
  );

  if ($input) {
    $term->addhistory($input);
    my $res = try {
      $cmdeng->parse_cmd
    } catch {
      $outfh->say( ">> Parser err: ".$_->message );
      next PROMPT
    };
    
    # convert subjects to CamelCase:
    my $subj = join '', map {; ucfirst } split ' ', lc $res->subject;
    if ($subj eq 'Quit' || $subj eq 'Exit') {
      say ">> Bye!"; 
      exit 0
    }

    my $subj_obj = try {
      use_module("App::vaporcalc::Cmd::Subject::$subj")->new
    } catch {
      $outfh->say( ">> Cannot load subject: ".$res->subject.": $_" );
      next PROMPT
    };

    my $verb = $res->verb;
    my $meth = 'action_'.lc($verb);
    unless ($subj_obj->can($meth)) {
      $outfh->say( ">> Cannot find method $meth in pkg $subj" );
      next PROMPT
    }

    my $verb_result = try {
      $subj_obj->$meth( $recipe, $res->params )
    } catch {
      $outfh->say( ">> Runtime err: $verb: $_" );
      next PROMPT
    };

    if (is_RecipeObject $verb_result) {
      $recipe = $verb_result
    }

    if (is_RecipeResultSet $verb_result) {
      $recipe = $verb_result->recipe
      # FIXME automagically print formatted when we get a resultset back?
      # FIXME abstract out template from -simple ?
    }
  } 
}


say "Bye!"; exit 0
